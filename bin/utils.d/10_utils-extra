#!/usr/bin/env bash

export BUILD_DEBUG_DEFAULT=1

# taken from https://gist.github.com/DinoChiesa/3e3c3866b51290f31243
# which is derived from https://gist.github.com/epiloque/8cf512c6d64641bde388
# which is based on https://gist.github.com/pkuczynski/8665367
## works for arrays of hashes, as long as the hashes do not have arrays
## Gist comment: 'this one does not handle string with doublequotes inside'
### SYNTAX: parse_yaml <yaml_file> <prefix_of_variables>
### USAGE: eval $(parse_yaml file.yaml "YAMLFILE_"
### EXAMPLE:
###     file.yaml =
###         development:
###           adapter: mysql2
###           encoding: utf8
###           database: my_database
###           username: root
###           roles:
###             - admin
###             - developer
###             - guest
###           password:
###           users:
###             -
###               name: pineapple
###               role: admin
###             -
###               name: umbrella
###               role: developer
### DO: eval $(parse_yaml file.yaml "development_")
### OUTPUT:
###     development_adapter=("mysql2")
###     development_encoding=("utf8")
###     development_database=("my_database")
###     development_username=("root")
###     development_roles+=("admin")
###     development_roles+=("developer")
###     development_roles+=("guest")
###     development_users__name+=("pineapple")
###     development_users__role+=("admin")
###     development_users__name+=("umbrella")
###     development_users__role+=("developer")
### > echo ${development_roles[@]}
###   admin developer guest
function parse_yaml() {
    local prefix=$2
    local s='[[:space:]]*'
    local w='[a-zA-Z0-9_]*'
    local fs="$(echo @|tr @ '\034')"
    # local repl_dash=${3:-__}
    # awk '{ split($0,keyval,":"); keyval[1]=gensub("-","'${repl_dash}'","g",keyval[1]); print keyval[1] ":" keyval[2];}'

    # remove comments, then blank lines, then do what that other guy had it do
    sed -e "s|$s#.*||" -e "/^$s\$/d" "$1"                            \
    | sed -ne  "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
          -e   "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p"  \
    | awk -F"$fs" '{
          indent = length($1)/2;
          if (length($2) == 0) {
              conj[indent]="+";
          }
          else {
              conj[indent]="";
          }
          vname[indent] = $2;
          for (i in vname) {
              if (i > indent) {
                  delete vname[i];
              }
          }
          if (length($3) > 0) {
              vn="";
              for (i=0; i<indent; i++) {
                  vn=(vn)(vname[i])("_");
              }
              printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
          }
    }' \
    | sed 's/_=/+=/g'
}


function set-default-configvar() {
    local this_var=$1  # no spaces in var name
    local this_val="$2"
    local default="$3"

    # this must be shortened...
    if [ -s "$this_val" ]; then
        export $this_var=$(cat "$this_val" 2>/dev/null | head -n1 || echo "$default")
    else
        export $this_var="$default"
    fi
}


function print-env() {
    echo ""
    puts-step "Current environment:"
    env | sort |& indent
    echo ""
}


indent-debug() {
    #RE="s/^/       /"
    if [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ]; then
        indent
    fi
    return ${PIPESTATUS[0]}
}


function do-debug() {
    if [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ]; then
        puts-step "DEBUG: $@"
    fi
}


# print a lot of stuff
function debug_heavy() {
    local EXTRA="|$1"
    do-debug "Relevant local variables:"
    set -o posix && set | sort | grep -E "HOMEBREW|PATH|HOME|APP_DIR|PACKAGE_EXTRAS" |& indent
}


function min() {
    A=$(( ${1:-1} * 1)); B=$(( ${2:-1} * 1))
    python3 -c "print(min("$A","$B"))"
}


function max() {
    A=$(( ${1:-1} * 1)); B=$(( ${2:-1} * 1));
    python3 -c "print(max("$A","$B"))"
}


function time_elapsed() {
    ELAPSED=$(awk '{printf "%f", $1 - $2}' <<< "$(date +'%s.%N') ${BUILD_START_TIME}")
    echo $(date --date=@$ELAPSED +'%M:%S:%2N') $@
    unset ELAPSED
}


# Syntax sugar.
function indent_notime() {
    # consider different annotations for stdout and stderr
    # http://stackoverflow.com/a/9113604/4106215
    # Things I've tried
    #     RE="s/^/\x1B[1G       /"
    #     RE="s/^/\r       /"
    #     RE="s/^/countdown 0 \"$@\"/e"
    #     RE="s/^/ $(countdown)      /"
    RE='s/^/        /'
    sed $SED_FLAG "$RE"
}


function time_remaining() {
    local TIME_REMAINING_FLOAT=$(time_remaining_float)
    declare -i TIME_REMAINING_INT=${TIME_REMAINING_FLOAT/.*/}
    echo ${TIME_REMAINING_INT}
}


function time_remaining_float() {
    awk '{printf "%f", $1 - $2}' <<< "${BUILD_MAX_RUNTIME} $(date +'%s.%N')"
}


# Get things from CONFIG_DIR
# arg1 = file to check for, cat contents if found
# arg2 = what to echo if file not found
get-configvar() {
    # get things from CONFIG_DIR
    CHECK_FOR="$1"
    DEFAULT="$2"
    if [ -f "$CHECK_FOR" ]; then
        cat "$CHECK_FOR" | head -n1 2>/dev/null
    else
        echo "$DEFAULT"
    fi
}


function unexport_configvar() {
    VAR="$1"
    do-debug "Unsetting $VAR"
    unset ${VAR}; unset VAR
}


# https://devcenter.heroku.com/articles/buildpack-api#bin-compile-summary
function export_env_dir() {
  env_dir=$1
  whitelist_regex=${2:-''}
  blacklist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH)$'}
  if [ -d "$env_dir" ]; then
    for e in $(ls $env_dir); do
      echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" &&
      export "$e=$(cat $env_dir/$e)"
      :
    done
  fi
}


# export_all_configvars & export_configvar are modified versions of Heroku's export_env_dir
function export_configvar() {
    #set +e  # don't exit if error
    #set -x
    local VAR=$1
    local DEFAULT=$2
    export "$VAR=$(cat $CONFIG_DIR/$VAR 2>/dev/null)"
      :
    export "$VAR=${!VAR:-$DEFAULT}"
      :
    do-debug "$VAR=${!VAR}"
}


function export_all_configvars() {
  env_dir=$1
  whitelist_regex=${2:-''}
  blacklist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH)$'}
  if [ -d "$env_dir" ]; then
    for e in $(ls $env_dir); do
      echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" &&
      export "$e=$(cat $env_dir/$e)"
      :
    done
  fi
}


function unexport_all_configvars() {
    for f in $(ls -A ${CONFIG_DIR}); do
        unexport_configvar ${f}
    done
    unset f
}


function change_shell_default() {
    # doesnt work
    export ORIG_SHELLOPTS=$SHELLOPTS
    export ORIG_BASHOPTS=$BASHOPTS
    export ORIG_PS4=$PS4
}


function reset_shell_default() {
    # doesnt work
    export PS4=${ORIG_PS4:-PS4}
    case $1 in
    shopt)
        shopt $2 $3
    ;;
    set)
        set $2 $3
    ;;
    esac
}


function proper_word() {
    local STR="$1"
    declare -u STRU="${STR:0:1}"
    local STRN=${#STR}
    declare -l STRL="${STR:1:$STRN}"
    echo "${STRU}${STRL}"
}


function proc_watcher() {

    ## IMPORTANT:
    #  If an argument has "quotes" or 'quotes' the arguments should be passed as \"quotes\" or \'quotes\'

    ## This thing does:
    # 1.) Traps the brew process id
    # 2.) Sends it to the background
    # 3.) Loops checking on time_remaining
    # 4.) If time_remaining==0 then kill brew with SIGTERM
    ## Why SIGTERM?
    # http://stackoverflow.com/a/690631/4106215
    # https://www.gnu.org/software/libc/manual/html_node/Program-Error-Signals.html#index-SIGABRT
    # https://www.gnu.org/software/make/manual/html_node/Interrupts.html
    # https://bash.cyberciti.biz/guide/Sending_signal_to_Processes#kill_-_send_a_signal_to_a_process
    ## Notes:
    # if anything in this trap process is f'd up then the whole thing fails
    # this is the most important part of the whole buildpack
    ## About brilliant PIPESTATUS:
    # http://stackoverflow.com/a/1221870/4106215
    ## The jobs -x thing is passing the wrong process sometimes, this gets it directly
    # declare -xi JOB_PID=$(jobs -l | grep -E '\[[0-9]+\]\+' | cut -d'+' -f2 | sed 's/^\s*\([0-9]\+\).\+/\1/')

    ## Instructions here continued from step (3) in brew_do
    # 3a.)
    declare -i JOB_PID JOB_ID RTN_STATUS KILL_RETRIES=0 SLEEP_TIME=30
    declare -i TIME_REMAINING=$(time_remaining)
    declare -i LAST_SLEEP_TIME=$((TIME_REMAINING - SLEEP_TIME))

    set_sleep_time() {
        [ ${TIME_REMAINING} -le 120 ] && SLEEP_TIME=20 || \
        [ ${TIME_REMAINING} -le 60  ] && SLEEP_TIME=10 || \
        [ ${TIME_REMAINING} -le 30  ] && SLEEP_TIME=5  || \
        [ ${TIME_REMAINING} -le 10  ] && SLEEP_TIME=1  || true
        LAST_SLEEP_TIME=$((TIME_REMAINING - SLEEP_TIME))
    }
    assign_job_vars() {  # used in 'jobs -x'
        JOB_ID=$1
        JOB_PID=$(jobs -p %${JOB_ID})
        echo_debug "jobs -l:"
        jobs -l
        echo_debug "JOB_ID=$JOB_ID"
        echo_debug "JOB_PID=$JOB_PID"
    }
    pid_exists() {
        echo $(kill -0 %${JOB_ID} |& grep --count .)
    }
    # these are necessary because any indentation is done when this function is called
    echo_debug() {
        [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ] && echo "DEBUG: $@" || true
        return ${PIPESTATUS[0]}
    }

    "$@"  # <--<--<-- raw execute whatever was passed <--<--<--
    jobs -x 'assign_job_vars' %+

    # 3c.)
    while [ $(pid_exists) -eq 0 ]; do  # checks if the process is still active
        local TIME_REMAINING=$(time_remaining)

        # 3c-i.)
        if [ ${TIME_REMAINING} -gt 0 -a ${TIME_REMAINING} -le ${LAST_SLEEP_TIME} ]; then

            # 3c-i-1.)
            echo "..... $(date --date=@${TIME_REMAINING} +'%M:%S') until abort"
            set_sleep_time

        # 3c-ii.)
        elif [ ${TIME_REMAINING} -le 0 ]; then

            # 3c-ii-1.)
            echo '! Out of time!'
            declare -u KILLSIG
            while [ 1 ]; do

                case ${KILL_RETRIES} in
                    0) KILLSIG=SIGTERM ;;
                    1) KILLSIG=SIGINT  ;;
                    2) KILLSIG=SIGABRT ;;
                    3) KILLSIG=SIGQUIT ;;
                    *) echo "! Something's way wrong. Killing the $1 altogether with SIGKILL."
                       kill -SIGKILL %${JOB_ID} #&
                       RTN_STATUS=$?
                       sleep 5
                       return ${RTN_STATUS}
                    ;;
                esac

                echo "! Aborting with $KILLSIG"
                kill -${KILLSIG} %${JOB_ID} #&
                RTN_STATUS=$?

                # 3c-ii-2.)
                [ $(pid_exists) -gt 0 ] && let ++KILL_RETRIES || return ${RTN_STATUS}
                sleep 5  # wait for the kill signal to work

            done
        fi
    done

    # 3d.)
    echo_debug "Waiting on $1 return status"
    wait %${JOB_ID}
    declare -i WAIT_RTN_STATUS=$?
    echo_debug "WAIT_RTN_STATUS=$WAIT_RTN_STATUS"

    # 3e.)
    RTN_STATUS=${WAIT_RTN_STATUS:-$RTN_STATUS}
    echo_debug "Leaving ${FUNCNAME[0]} with RTN_STATUS = $RTN_STATUS"
    return ${RTN_STATUS}
}
