#!/usr/bin/env bash

export BUILD_DEBUG_DEFAULT=1

# taken from https://gist.github.com/DinoChiesa/3e3c3866b51290f31243
# which is derived from https://gist.github.com/epiloque/8cf512c6d64641bde388
# which is based on https://gist.github.com/pkuczynski/8665367
## works for arrays of hashes, as long as the hashes do not have arrays
## Gist comment: 'this one does not handle string with doublequotes inside'
### SYNTAX: parse_yaml <yaml_file> <prefix_of_variables>
### USAGE: eval $(parse_yaml file.yaml "YAMLFILE_"
### EXAMPLE:
###     file.yaml =
###         development:
###           adapter: mysql2
###           encoding: utf8
###           database: my_database
###           username: root
###           roles:
###             - admin
###             - developer
###             - guest
###           password:
###           users:
###             -
###               name: pineapple
###               role: admin
###             -
###               name: umbrella
###               role: developer
### DO: eval $(parse_yaml file.yaml "development_")
### OUTPUT:
###     development_adapter=("mysql2")
###     development_encoding=("utf8")
###     development_database=("my_database")
###     development_username=("root")
###     development_roles+=("admin")
###     development_roles+=("developer")
###     development_roles+=("guest")
###     development_users__name+=("pineapple")
###     development_users__role+=("admin")
###     development_users__name+=("umbrella")
###     development_users__role+=("developer")
### > echo ${development_roles[@]}
###   admin developer guest
function parse_yaml() {
    local prefix=$2
    local s='[[:space:]]*'
    local w='[a-zA-Z0-9_]*'
    local fs="$(echo @|tr @ '\034')"
    # local repl_dash=${3:-__}
    # awk '{ split($0,keyval,":"); keyval[1]=gensub("-","'${repl_dash}'","g",keyval[1]); print keyval[1] ":" keyval[2];}'

    # remove comments, then blank lines, then do what that other guy had it do
    sed -ue "s|$s#.*||" -e "/^$s\$/d" "$1"                            \
    | sed -ne  "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
          -e   "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p"  \
    | awk -F"$fs" '{
          indent = length($1)/2;
          if (length($2) == 0) {
              conj[indent]="+";
          }
          else {
              conj[indent]="";
          }
          vname[indent] = $2;
          for (i in vname) {
              if (i > indent) {
                  delete vname[i];
              }
          }
          if (length($3) > 0) {
              vn="";
              for (i=0; i<indent; i++) {
                  vn=(vn)(vname[i])("_");
              }
              printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
          }
    }' \
    | sed -u 's/_=/+=/g'
}


function set-default-configvar() {
    local this_var=$1  # no spaces in var name
    local this_val="$2"
    local default="$3"

    # this must be shortened...
    if [ -s "$this_val" ]; then
        export $this_var=$(cat "$this_val" 2>/dev/null | head -n1 || echo "$default")
    else
        export $this_var="$default"
    fi
}


function print-env() {
    echo ""
    puts-step "Current environment:"
    env | sort |& indent
    echo ""
}


indent-debug() {
    #RE="s/^/       /"
    if [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ]; then
        indent
    fi
    return ${PIPESTATUS[0]}
}


function do-debug() {
    if [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ]; then
        RE='s/^/ ~~~~~> DEBUG: /; e countdown;' && \
        echo $@ | sed ${SED_FLAG} "$RE"  || \
        echo " ~~~~~> DEBUG: $@"
    fi
}


# print a lot of stuff
function debug_heavy() {
    local EXTRA="|$1"
    do-debug "Relevant local variables:"
    set -o posix && set | sort | grep -E "HOMEBREW|PATH|HOME|APP_DIR|PACKAGE_EXTRAS" |& indent
}


function min() {
    A=$(( ${1:-1} * 1)); B=$(( ${2:-1} * 1))
    python3 -c "print(min("$A","$B"))"
}


function max() {
    A=$(( ${1:-1} * 1)); B=$(( ${2:-1} * 1));
    python3 -c "print(max("$A","$B"))"
}


function time_elapsed() {
    ELAPSED=$(awk '{printf "%f", $1 - $2}' <<< "$(date +'%s.%N') ${BUILD_START_TIME}")
    echo $(date --date=@$ELAPSED +'%M:%S:%2N') $@
    unset ELAPSED
}


# Syntax sugar.
function indent_notime() {
    # consider different annotations for stdout and stderr
    # http://stackoverflow.com/a/9113604/4106215
    # Things I've tried
    #     RE="s/^/\x1B[1G       /"
    #     RE="s/^/\r       /"
    #     RE="s/^/countdown 0 \"$@\"/e"
    #     RE="s/^/ $(countdown)      /"
    RE='s/^/        /'
    sed $SED_FLAG "$RE"
}


function time_remaining() {
    local TIME_REMAINING_FLOAT=$(time_remaining_float)
    declare -i TIME_REMAINING_INT=${TIME_REMAINING_FLOAT/.*/}
    echo ${TIME_REMAINING_INT}
}


function time_remaining_float() {
    awk '{printf "%f", $1 - $2}' <<< "${BUILD_MAX_RUNTIME} $(date +'%s.%N')"
}


# Get things from CONFIG_DIR
# arg1 = file to check for, cat contents if found
# arg2 = what to echo if file not found
get-configvar() {
    # get things from CONFIG_DIR
    CHECK_FOR="$1"
    DEFAULT="$2"
    if [ -f "$CHECK_FOR" ]; then
        cat "$CHECK_FOR" | head -n1 2>/dev/null
    else
        echo "$DEFAULT"
    fi
}


function unexport_configvar() {
    VAR="$1"
    do-debug "Unsetting $VAR"
    unset ${VAR}; unset VAR
}


# https://devcenter.heroku.com/articles/buildpack-api#bin-compile-summary
function export_env_dir() {
  env_dir=$1
  whitelist_regex=${2:-''}
  blacklist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH)$'}
  if [ -d "$env_dir" ]; then
    for e in $(ls $env_dir); do
      echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" &&
      export "$e=$(cat $env_dir/$e)"
      :
    done
  fi
}


# export_all_configvars & export_configvar are modified versions of Heroku's export_env_dir
function export_configvar() {
    #set +e  # don't exit if error
    #set -x
    local VAR=$1
    local DEFAULT=$2
    export "$VAR=$(cat $CONFIG_DIR/$VAR 2>/dev/null)"
      :
    export "$VAR=${!VAR:-$DEFAULT}"
      :
    do-debug "$VAR=${!VAR}"
}


function export_all_configvars() {
  env_dir=$1
  whitelist_regex=${2:-''}
  blacklist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH)$'}
  if [ -d "$env_dir" ]; then
    for e in $(ls $env_dir); do
      echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" &&
      export "$e=$(cat $env_dir/$e)"
      :
    done
  fi
}


function unexport_all_configvars() {
    for f in $(ls -A ${CONFIG_DIR}); do
        unexport_configvar ${f}
    done
    unset f
}


function change_shell_default() {
    # doesnt work
    export ORIG_SHELLOPTS=$SHELLOPTS
    export ORIG_BASHOPTS=$BASHOPTS
    export ORIG_PS4=$PS4
}


function reset_shell_default() {
    # doesnt work
    export PS4=${ORIG_PS4:-PS4}
    case $1 in
    shopt)
        shopt $2 $3
    ;;
    set)
        set $2 $3
    ;;
    esac
}


function proper_word() {
    local STR="$1"
    declare -u STRU="${STR:0:1}"
    local STRN=${#STR}
    declare -l STRL="${STR:1:$STRN}"
    echo "${STRU}${STRL}"
}


function get_orig_opt() {
    echo $(shopt -po ${1} || true)
}


function do_kill() {
    local SIGNAL=$1
    local PID=$2
    [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ] && local ORIG_XTRACE=$(get_orig_opt xtrace) && set -x || true
    local WAIT=${3:-5}
    pkill --signal ${SIGNAL} --pgroup ${PID} || true
    pkill --signal ${SIGNAL} --parent ${PID} || true
    kill -${SIGNAL} -- -${PID} || true
    kill -${SIGNAL} -${PID} || true
    kill -${SIGNAL} ${PID} || true
    local RTN=$?
    sleep ${WAIT}
    return ${RTN}
    ${ORIG_XTRACE}
}


function proc_watcher() {

    ## IMPORTANT:
    #  If an argument has "quotes" or 'quotes' the arguments should be passed as \"quotes\" or \'quotes\'

    ## USAGE:
    # proc_watcher [ 1 to enforce time limit, 0 to not ] [ command and args ]

    ## This thing does:
    # 1.) Traps the brew process id
    # 2.) Sends it to the background
    # 3.) Loops checking on time_remaining
    # 4.) If time_remaining==0 then kill brew with SIGTERM
    ## Why SIGTERM?
    # http://stackoverflow.com/a/690631/4106215
    # https://www.gnu.org/software/libc/manual/html_node/Program-Error-Signals.html#index-SIGABRT
    # https://www.gnu.org/software/make/manual/html_node/Interrupts.html
    # https://bash.cyberciti.biz/guide/Sending_signal_to_Processes#kill_-_send_a_signal_to_a_process
    ## Notes:
    # if anything in this trap process is f'd up then the whole thing fails
    # this is the most important part of the whole buildpack
    ## About brilliant PIPESTATUS:
    # http://stackoverflow.com/a/1221870/4106215
    ## The jobs -x thing is passing the wrong process sometimes, this gets it directly
    # declare -xi JOB_PID=$(jobs -l | grep -E '\[[0-9]+\]\+' | cut -d'+' -f2 | sed -u 's/^\s*\([0-9]\+\).\+/\1/')

    ## Instructions here continued from step (3) in brew_do
    # 3a.)
    declare -i ENFORCE_TIME_LIMIT=$1
    declare -i SLEEP_TIME=30
    declare -i TIME_LEFT=$(time_remaining)
    declare -i LAST_SLEEP_TIME=$((TIME_LEFT - SLEEP_TIME))
    declare -i RTN_STATUS=0
    export RTN_STATUS_TMPFILE=$(mktemp)
    declare -i JOB_PID JOB_PID_DOLL_EXCLAM JOB_ID KILL_RETRIES
    local THE_EXE=$2
    local THIS_PID=$$

    get_sleep_time() {
        declare -i REM=$(time_remaining)
        [ ${REM} -le 120 ] && printf 20 || \
        [ ${REM} -le 60  ] && printf 10 || \
        [ ${REM} -le 30  ] && printf 5  || \
        [ ${REM} -le 10  ] && printf 1  || \
        printf ${SLEEP_TIME} || true
    }
    assign_job_vars() { JOB_ID=$1; JOB_PID=$(jobs -p %${JOB_ID} 2>/dev/null || echo -n ${JOB_PID_DOLL_EXCLAM}); }
    # kill -0 prints nothing if the job is running, and an error to stderr if its not
    pid_exists() { declare -i ZERO_IF_EXIST=$(kill -0 %${JOB_ID} |& grep -cm 1 .); echo -n $((1 - ZERO_IF_EXIST)); }
    jobs_running() { echo -n $(jobs -r %${JOB_ID} 2>/dev/null | grep -cm 1 .); }
    # these are necessary because any indentation is done when this function is called
    indent_local() { sed -u 's/^/        /'; }
    indent_debug_local() { if [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ]; then sed -u 's/^/       /'; fi; }
    do_debug_local() { if [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ]; then echo "~~~~~> DEBUG: $@"; fi; }
    puts_step_local() { echo "-----> $@"; }
    puts_warn_local() { echo "!      $@"; }
    wait_for_result_local() {
        local X=$(cat "${RTN_STATUS_TMPFILE}")
        while [ ${#X} -eq 0 ]; do
            if [ $(time_remaining) -gt 0 ] || [ ${ENFORCE_TIME_LIMIT} -eq 0 ]; then
                X=$(cat "${RTN_STATUS_TMPFILE}"); sleep 1
            else
                X=232
            fi
        done
        echo -n ${X}
    }
    var_debug_local() {
        do_debug_local "jobs -l:"
        jobs -l |& indent_debug_local
        do_debug_local "ENFORCE_TIME_LIMIT=$ENFORCE_TIME_LIMIT"
        do_debug_local "JOB_PID_DOLL_EXCLAM=$JOB_PID_DOLL_EXCLAM"
        do_debug_local "SLEEP_TIME=$SLEEP_TIME"
        do_debug_local "TIME_LEFT=$TIME_LEFT"
        do_debug_local "LAST_SLEEP_TIME=$LAST_SLEEP_TIME"
        do_debug_local "\$(jobs_running)=$(jobs_running)"
        do_debug_local "\$(pid_exists)=$(pid_exists)"
        do_debug_local "${RTN_STATUS_TMPFILE} contents: $(cat ${RTN_STATUS_TMPFILE})"
        do_debug_local "JOB_ID=$JOB_ID"
        do_debug_local "JOB_PID=$JOB_PID"
        do_debug_local "THE_EXE=$THE_EXE"
        do_debug_local "THIS_PID=$THIS_PID"
        do_debug_local "\$(pgrep -a \$THE_EXE)=$(pgrep -a ${THE_EXE})"
        do_debug_local "\$(pgrep -a -P \$THIS_PID)=$(pgrep -a -P ${THIS_PID})"
        do_debug_local "\$(pgrep -a -P \$JOB_PID)=$(pgrep -a -P ${JOB_PID})"
        #ps axjf | sed "s;$(cd $(dirname $0); pwd);BUILDPACK_BIN;g; s;$CACHE_DIR;CACHE_DIR;g; s;$BUILD_DIR;BUILD_DIR;g; s;$ORIG_BUILD_DIR;ORIG_BUILD_DIR;g; s;$BIN_DIR;BIN_DIR;g"
        #ps axjf | sed "s;$BIN_DIR;BIN_DIR;g; s;$CACHE_DIR;CACHE_DIR;g; s;$BUILD_DIR;BUILD_DIR;g; s;$ORIG_BUILD_DIR;ORIG_BUILD_DIR;g; s;$CONFIG_DIR;CONFIG_DIR;g"
        return 0
    }


    if [ 1 ]; then
        [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ] && local ORIG_XTRACE=$(get_orig_opt xtrace) && set -x || true
        { "${@:2}"; echo -n $? > ${RTN_STATUS_TMPFILE}; } &  # <--<--<-- raw execute in background whatever was passed <--<--<--
        JOB_PID_DOLL_EXCLAM=$!
        ${ORIG_XTRACE} #2>/dev/null || true
    fi
    jobs -x 'assign_job_vars' %+

    var_debug_local

    # 3c.)
    while [ ! $(cat "${RTN_STATUS_TMPFILE}") ]; do

        local TIME_LEFT=$(time_remaining)
        if [ ${TIME_LEFT} -gt 0 ] || [ ${ENFORCE_TIME_LIMIT} -eq 0 ]; then

            # 3c-i-1.)
            if [ ${TIME_LEFT} -le ${LAST_SLEEP_TIME} ]; then
                echo "..... $(date --date=@${TIME_LEFT} +'%M:%S') until abort"
                LAST_SLEEP_TIME=$((TIME_LEFT - $(get_sleep_time)))
                var_debug_local
            fi

        # 3c-ii.)
        elif [ ${TIME_LEFT} -le 0 ]; then

            # 3c-ii-1.)
            puts_warn_local 'Out of time!!'
            declare -u KILLSIG
            while [ 1 ]; do
                # FIXME: this hangs and doesnt exit
                do_debug_local "KILL_RETRIES=$KILL_RETRIES"
                case ${KILL_RETRIES:=0} in
                    0)
                        KILLSIG=SIGINT  ;;
                    1)
                        KILLSIG=SIGABRT ;;
                    2)
                        KILLSIG=SIGTERM ;;
                    3)
                        KILLSIG=SIGQUIT ;;
                    3)
                        KILLSIG=SIGSTOP ;;  # only SIGSTOP and SIGKILL cannot be ignored
                    *)
                        puts_warn_local "Something's way wrong. Killing $2 altogether with SIGKILL."
                        do_kill SIGKILL ${JOB_PID} 5
                        RTN_STATUS=$?
                        return ${RTN_STATUS}
                    ;;
                esac

                puts_warn_local "Aborting with $KILLSIG"
                do_kill ${KILLSIG} ${JOB_PID} 5
                do_debug_local "Sent $KILLSIG"
                RTN_STATUS=$?

                var_debug_local

                # 3c-ii-2.)
                sleep 5  # wait for the kill signal to work
                local KILL_RETRIES_ORD
                case ${KILL_RETRIES: -1} in
                    1) KILL_RETRIES_ORD="${KILL_RETRIES}st";;
                    2) KILL_RETRIES_ORD="${KILL_RETRIES}nd";;
                    3) KILL_RETRIES_ORD="${KILL_RETRIES}rd";;
                    *) KILL_RETRIES_ORD="${KILL_RETRIES}th";;
                esac
                if [ $(pid_exists) -gt 0 ]; then
                    let ++KILL_RETRIES
                    puts_warn_local "$KILLSIG hasn't worked yet. Continuing with $KILL_RETRIES_ORD try."
                else
                    puts_step_local "$KILLSIG worked on the $KILL_RETRIES_ORD try."
                    return ${RTN_STATUS}
                fi

            done
        fi
        sleep 1
    done

    var_debug_local

    # 3d.)
    do_debug_local "Waiting on $2 return status"
    declare -i JOB_RESULT=$(wait_for_result_local)
    rm -f "${RTN_STATUS_TMPFILE}" &>/dev/null; unset RTN_STATUS_TMPFILE
    do_debug_local "JOB_RESULT=$JOB_RESULT"

    # 3e.)
    RTN_STATUS=${JOB_RESULT:-$RTN_STATUS}
    do_debug_local "Leaving ${FUNCNAME[0]} with RTN_STATUS = $RTN_STATUS"
    return ${RTN_STATUS}
}
