#!/usr/bin/env bash

export BUILD_DEBUG_DEFAULT=1

# taken from https://gist.github.com/DinoChiesa/3e3c3866b51290f31243
# which is derived from https://gist.github.com/epiloque/8cf512c6d64641bde388
# which is based on https://gist.github.com/pkuczynski/8665367
## works for arrays of hashes, as long as the hashes do not have arrays
## Gist comment: 'this one does not handle string with doublequotes inside'
### SYNTAX: parse_yaml <yaml_file> <prefix_of_variables>
### USAGE: eval $(parse_yaml file.yaml "YAMLFILE_"
### EXAMPLE:
###     file.yaml =
###         development:
###           adapter: mysql2
###           encoding: utf8
###           database: my_database
###           username: root
###           roles:
###             - admin
###             - developer
###             - guest
###           password:
###           users:
###             -
###               name: pineapple
###               role: admin
###             -
###               name: umbrella
###               role: developer
### DO: eval $(parse_yaml file.yaml "development_")
### OUTPUT:
###     development_adapter=("mysql2")
###     development_encoding=("utf8")
###     development_database=("my_database")
###     development_username=("root")
###     development_roles+=("admin")
###     development_roles+=("developer")
###     development_roles+=("guest")
###     development_users__name+=("pineapple")
###     development_users__role+=("admin")
###     development_users__name+=("umbrella")
###     development_users__role+=("developer")
### > echo ${development_roles[@]}
###   admin developer guest
function parse_yaml() {
    local prefix=$2
    local s
    local w
    local fs
    s='[[:space:]]*'
    w='[a-zA-Z0-9_]*'
    fs="$(echo @|tr @ '\034')"
    sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" \
        "$1" \
    | awk -F"$fs" '{
      indent = length($1)/2;
      if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
              vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
              printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
      }
    }' \
    | sed 's/_=/+=/g'
}

function set-default-configvar() {
    local this_var=$1  # no spaces in var name
    local this_val="$2"
    local default="$3"

    # this must be shortened...
    if [ -s "$this_val" ]; then
        export $this_var=$(cat "$this_val" 2>/dev/null | head -n1 || echo "$default")
    else
        export $this_var="$default"
    fi
}

function print-env() {
    echo ""
    puts-step "Current environment:"
    env | sort |& indent
    echo ""
}

indent-debug() {
    RE="s/^/       /"
    if [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ]; then
    #if [ ${BUILD_DEBUG} -gt 0 ]; then
        sed $SED_FLAG "$RE"
    fi
}

function do-debug() {
    if [ ${BUILD_DEBUG:-$BUILD_DEBUG_DEFAULT} -gt 0 ]; then
    #if [ ${BUILD_DEBUG} -gt 0 ]; then
        echo "-----> DEBUG1: $@"
    fi
}
#alias do_debug='do-debug'

# print a lot of stuff
function debug_heavy() {
    local EXTRA="|$1"
    do-debug "Relevant local variables:"
    set -o posix && set | sort | grep -E "HOMEBREW|PATH|HOME|APP_DIR|PACKAGE_EXTRAS" |& indent
}

function min() {
    #A=${1:-1}; B=${2:-1}; #ABSMIN=$3;
    A=$(( ${1:-1} * 1)); B=$(( ${2:-1} * 1))
#    A=${A/ /}; B=${B/ /};
#    A=$(($A * 1)); B=$(($B * 1));
#    if [ ! ${#ABSMIN} -gt 0 ] || [ ! $(( $ABSMIN + 0 )) -eq $ABSMIN ]; then ABSMIN=1; fi
#    if [ ! ${#A} -gt 0 ] && [ ! $A -ge $ABSMIN ]; then A=$ABSMIN; fi
#    if [ ! ${#B} -gt 0 ] && [ ! $B -ge $ABSMIN ]; then B=$ABSMIN; fi
    python3 -c "print(min("$A","$B"))"
}

function max() {
    #A=${1:-1}; B=${2:-1}; #ABSMIN=$3;
    A=$(( ${1:-1} * 1)); B=$(( ${2:-1} * 1));
#    A=${A/ /}; B=${B/ /};
#    A=$(($A * 1)); B=$(($B * 1));
#    if [ ! ${#ABSMIN} -gt 0 ] || [ ! $(( $ABSMIN + 0 )) -eq $ABSMIN ]; then ABSMIN=1; fi
#    if [ ! ${#A} -gt 0 ] && [ ! $A -ge $ABSMIN ]; then A=$ABSMIN; fi
#    if [ ! ${#B} -gt 0 ] && [ ! $B -ge $ABSMIN ]; then B=$ABSMIN; fi
    python3 -c "print(max("$A","$B"))"
}

function time_remaining() {
    echo $(( $BUILD_MAX_RUNTIME - $(date +'%s') ))
}

# Get things from CONFIG_DIR
# arg1 = file to check for, cat contents if found
# arg2 = what to echo if file not found
get-configvar() {
    # get things from CONFIG_DIR
    CHECK_FOR="$1"
    DEFAULT="$2"
    if [ -f "$CHECK_FOR" ]; then
        cat "$CHECK_FOR" | head -n1 2>/dev/null
    else
        echo "$DEFAULT"
    fi
}

function unexport_configvar() {
    VAR="$1"
    do-debug "Unsetting $VAR"
    unset ${VAR}; unset VAR
}

# https://devcenter.heroku.com/articles/buildpack-api#bin-compile-summary
function export_env_dir() {
  env_dir=$1
  whitelist_regex=${2:-''}
  blacklist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH)$'}
  if [ -d "$env_dir" ]; then
    for e in $(ls $env_dir); do
      echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" &&
      export "$e=$(cat $env_dir/$e)"
      :
    done
  fi
}

# export_all_configvars & export_configvar are modified versions of Heroku's export_env_dir

function export_configvar() {
    #set +e  # don't exit if error
    #set -x
    local VAR=$1
    local DEFAULT=$2
    export "$VAR=$(cat $CONFIG_DIR/$VAR)"
      :
    export "$VAR=${!VAR:-$DEFAULT}"
      :
    do-debug "$VAR=${!VAR}"
#    local ISAV=$(ls -A ${CONFIG_DIR} | grep --count "$VAR")
#    if [ $ISAV -gt 0 ]; then
#        SET_TO=$(cat ${CONFIG_DIR}/${VAR} | head -n1) #|& indent-debug #|| SET_TO="$DEFAULT"
#    else
#        SET_TO=$DEFAULT
#    fi
#    export "$VAR=$SET_TO" #|| puts-warn "Unable to set configvar $VAR to \"$SET_TO\""
    #set +x
    #set -e  # exit if error
}

function export_all_configvars() {
#    for f in $(ls -A ${CONFIG_DIR}); do
#        export_configvar ${f}
#    done
#    unset f
  env_dir=$1
  whitelist_regex=${2:-''}
  blacklist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH)$'}
  if [ -d "$env_dir" ]; then
    for e in $(ls $env_dir); do
      echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" &&
      export "$e=$(cat $env_dir/$e)"
      :
    done
  fi
}

function unexport_all_configvars() {
    for f in $(ls -A ${CONFIG_DIR}); do
        unexport_configvar ${f}
    done
    unset f
}
